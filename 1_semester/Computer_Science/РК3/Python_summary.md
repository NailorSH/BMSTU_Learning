# Рубежный контроль № 3: конспект по скриптовому языку Python
#### 20 декабря 2022 г.
#### Наиль Шиятов, ИУ9-11Б

## **1. Типизация - строгая неявная динамическая**

   _Строгая (сильная) типизация – язык не позволяет смешивать в выражениях различные типы 
   и не выполняет автоматические неявные преобразования, например, нельзя вычесть из строки 
   множество._

   _Неявная типизация означает, что при объявлении переменной не нужно указывать её тип._
   
   _Динамическая типизация – переменная связывается с типом в момент присваивания значения, а не в 
   момент объявления переменной._



### К основным встроенным типам относятся: 

1. **None** (неопределенное значение переменной) 
2. **Логические переменные** (Boolean Type) 
3. **Числа** (Numeric Type)
     * int - целое число 
     * float - число с плавающей точкой
     * complex - комплексное число 
4. **Списки** (Sequence Type) 
     * list - список 
     * tuple - кортеж 
     * range - диапазон 
5. **Строки** (Text Sequence Type) 
     * str 
6. **Бинарные списки** (Binary Sequence Types)
     * bytes - байты 
     * bytearray - массивы байт 
     * memoryview - специальные объекты для доступа к внутренним данным объекта черезprotocol buffer 
7. **Множеста** (Set Types)
     * set - множество 
     * frozenset - неизменяемое множество 
8. **Словари** (Mapping Types)
     * dict - словарь

## **2. Основные управляющие конструкции**
### Определение функций
``` python
def name(arguments):
   body
```
> определение функции `name` cо списком параметров, заключенным в скобки `(arguments)` и набором 
инструкций `body`

### Условия
``` python
if something1: 
    do1() 
elif something2: 
    do2() 
elif something3: 
    do3() 
#... 
elif somethingN: 
    doN() 
else: 
    do_something_else()
```
> *`elif` части может быть ноль или больше , `else` часть является необязательной.*

### Циклы
**Цикл `for`  в Python выполняет итерации по элементам любой последовательности (список или строка) 
в том порядке, в котором они появляются в указанной последовательности**
``` python
for item in iterable: 
     expression
```
>  где `iterable` это итерируемый объект. В роли такого объекта могут выступать строки, списки, 
кортежи, словари, а также любой класс, объявленный с методами `__iter__` или `__getitem__`, 
`range` также может быть итерируемым объектом.
------------------------

**`while` - цикл с предусловием, который выполняется пока истинно некоторое условие, указанное 
перед его началом.**
```
while condition: 
    loop_body
```

### Функция range()
`range()` **генерирует арифметические прогрессии**, в первом случае, от `start` до `end` с шагом 
(приращением) `step`, или, во втором случае, от 0 до `n`
``` python
range(start, end, step)
range(n)
```

### Операторы break, continue и else в циклах
* `break` - прерывает выполнение цикла
* `continue` - прерывает текущую итерацию и переходит к следующей
* `else` выполняется, когда цикл завершается из-за исчерпания итераций (`for`), или, когда условие 
становится ложным (`while`), но не тогда, когда цикл завершается `break` оператором

### Pass инструкции
Оператор`pass` ничего не делает. Его можно использовать, когда синтаксически требуется оператор, но 
программа не требует никаких действий. Например:
``` python
while True:
    pass      # Ожидание прерывания с клавиатуры (Ctrl+C)
```

### Match инструкции
Оператор `match` принимает выражение и сравнивает его значение с последовательными шаблонами, 
заданными в виде одного или нескольких блоков `case`. Выполняется только первый соответствующий 
шаблон, и он также может извлекать компоненты (элементы последовательности или атрибуты объекта) из 
значения в переменные.
``` python
match expr:
        case pat_1:
            action_1
        case pat_2:
            action_2
        ...        
        case pat_n:
            action_n
```


## **3. Подмножество языка для функционального программирования**
### Cпособы обеспечить иммутабельность данных там, где это необходимо
* **Использование неизменяемых структур данных:**
   * int
   * float 
   * complex 
   * string 
   * tuple 
   * frozenset (неизменяемая версия set) 
   * bytes
   
* **Использование модуля *collections***

> В Python функции являются объектами первого класса, что позволяет придерживаться функционального 
стиля, когда это необходимо
### Функции как объекты 1-го класса

**Функция, как объект первого класса, обладает рядом свойств. Функция:**
* может быть сохранена в переменной или структуре данных; 
* может быть передана в другую функцию как аргумент; 
* может быть возвращена из функции как результат; 
* может быть создана во время выполнения программы; 
* не должна зависеть от именования. 

### Функции высших порядков
> Функции высших порядков - функции, которые могут принимать в качестве аргументов и возвращать 
другие функции. Функции высших порядков позволяют использовать каррирование - это преобразование 
функции с множеством аргументов в набор вложенных функций с одним аргументом.
*Так как функции, которые передаются в качестве аргументов, как правило, небольшие по размеру, то 
для удобства, их конструируют в виде `lambda`-функции прямо в месте вызова.*

``` python
lambda list_arguments: expression
```

### Встроенные функции высших порядков для работы с последовательностями:
* `map()` - принимает функцию-аргумент и применяет её ко всем элементам входящей последовательности
* `filter()` - фильтрует последовательность по заданному условию
* `zip()` - упаковывает итерируемые объекты в один список кортежей. При работе ориентируется на 
объект меньшей длины
* `enumerate()` - возвращает индекс элемента и сам элемент последовательности в качестве кортежа

## **4. Важнейшие функции для работы с потоками ввода/вывода, строками, регулярными выражениями**

### Работа с потоками ввода/вывода
> Модуль `io` предоставляет основные средства Python для работы с различными типами ввода-вывода. 
Существует три основных типа ввода-вывода: *текстовый ввод-вывод, двоичный ввод-вывод* и 
*необработанный ввод-вывод*. Это общие категории, и для каждой из них могут использоваться различные 
резервные хранилища. Конкретный объект, принадлежащий к любой из этих категорий, называется файловым 
объектом.
1) **Текстовый ввод-вывод**
> Текстовый ввод-вывод ожидает и создает *str-объекты*
   * с помощью `open()`: `f = open("myfile.txt", "r", encoding="utf-8")`
   * через *StringIO-объекты*: `f = io.StringIO("some initial text data")`
2) **Двоичный ввод-вывод**
> Двоичный ввод-вывод ожидает объекты, подобные байтам, и создает объекты `bytes`. Кодирование, 
декодирование или перевод новой строки не выполняются.
   * использовать `open()` с `'b'` в строке mode: `f = open("myfile.jpg", "rb")`
   * через *BytesIO-объекты*: `f = io.BytesIO(b"some initial binary data: \x00\x01")`
3) **Необработанный ввод-вывод**
> Необработанный поток можно создать, открыв файл в двоичном режиме с отключенной буферизацией:
``` python
f = open("myfile.jpg", "rb", buffering=0)
```
### Работа со строками
* `S[i:j:step]` - извлечение среза
* `len(S)` - длина строки
* `S.find(str, [start],[end])` - поиск подстроки в строке. Возвращает номер первого вхождения или -1
* `S.index(str, [start],[end])` - поиск подстроки в строке. Возвращает номер первого вхождения или 
вызывает ValueError
* `S.replace(шаблон, замена[, maxcount])` - замена шаблона на замену. `maxcount` ограничивает 
количество замен
* `S.split(символ)` - разбиение строки по разделителю
* `S.upper()` - преобразование строки к верхнему регистру
* `S.lower()` - преобразование строки к нижнему регистру
* `S.title()` - первую букву каждого слова переводит в верхний регистр, а все остальные в нижний

### Работа с регулярными выражениями
> *Используется модуль `re`*
#### Основные функции:
* `re.search(pattern, string)` - найти в строке `string` первую строчку, подходящую под шаблон `pattern`
* `re.fullmatch(pattern, string)` - проверить, подходит ли строка `string` под шаблон `pattern`
* `re.split(pattern, string, maxsplit=0)` - аналог `str.split()`, только разделение происходит по 
подстрокам, подходящим под шаблон `pattern`
* `re.findall(pattern, string)` - найти в строке `string` все непересекающиеся шаблоны `pattern`
* `re.finditer(pattern, string)` - итератор всем непересекающимся шаблонам `pattern` в строке `string` 
(выдаются match-объекты)
* `re.sub(pattern, repl, string, count=0)` - заменить в строке `string` все непересекающиеся шаблоны 
`pattern` на `repl`